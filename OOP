В об'єктно-орієнтованому програмуванні, успадкува́ння (наслідування) — механізм утворення нових класів на основі використання вже існуючих. При цьому властивості та функціональність батьківського класу переходять до класу нащадка (дочірнього).
Принцип успадкування
Визначення нового класу (породжений клас, підклас, англ. derived class, англ. subclass) може базуватись на визначенні вже існуючого (базовий клас, англ. base class, англ. superclass). В такому випадку, новий клас отримає властивості та поведінку базового класу, та доповнить їх своїми власними. У випадку одиничного успадкування, у кожного класу може бути лише один безпосередній базовий клас. У випадку множинного успадкування, дозволяється існування декількох безпосередніх надкласів.

Представником мови, яка має явне множинне успадкування є C++. Оскільки при множинному успадкуванні виникає ряд проблем, тому у таких мовах, як наприклад D, Java, C# дозволяють явно тільки просте (одинарне) успадкування. У разі необхідності, у даних мовах множинне успадкування можна реалізувати за допомогою інтерфейсів.

Застосування механізму успадкування дозволяє покращити повторне використання коду шляхом використання вже визначених властивостей та методів (поведінки) базових класів.
Приклад С++
#include <iostream>
using namespace std;
 
class FirstClass    // базовий клас
{
protected:          // специфікатор доступа
    int value;
public:
    FirstClass()
    {
        value = 0;
    }
 
    FirstClass( int input )
    {
        value = input;
    }
 
    void show_value()
    {
        cout << value << endl;
    }
};
 
class SecondClass : public FirstClass   // похідний клас
{
public:
    SecondClass() : FirstClass ()   // конструктор класу SecondClass викликає конструктор класу FirstClass
    {}
 
    SecondClass(int inputS) : FirstClass (inputS)   // inputS передається в конструктор з параметром класу FirstClass
    {}
 
    void ValueSqr () // підносить value до квадрату. Без специфікатора доступа protected ця функція не могла б змінити значення value
    {
        value *= value;    
    }  
};
 
int main()
{
    setlocale(LC_ALL, "ukr");
 
    FirstClass F_object(3);     // об'єкт базового класу
    cout << "value F_object = ";
    F_object.show_value();
 
    SecondClass S_object(4);    // об'єкт похідного класу
    cout << "value S_object = ";
    S_object.show_value();  // виклик методу базового класу
 
    S_object.ValueSqr();        // value до квадрату
    cout << "квадрат value S_object = ";
    S_object.show_value();
 
    //F_object.ValueSqr();      // базовий клас не має доступу до методів похідного класу
 
    cout << endl;
    return 0;
}
Інкапсуляція — один з трьох основних механізмів об'єктно-орієнтованого програмування. Йдеться про те, що об’єкт вміщує не тільки дані, але і правила їх обробки, оформлені в вигляді виконуваних фрагментів (методів). А також про те, що доступ до стану об'єкта напряму заборонено, і ззовні з ним можна взаємодіяти виключно через заданий інтерфейс (відкриті поля та методи), що дозволяє знизити зв'язність. Таким чином контролюються звернення до полів класів та їхня правильна ініціалізація, усуваються можливі помилки пов'язані з неправильним викликом методу. Оскільки користувачі працюють лише через відкриті елементи класів, то розробники класу можуть як-завгодно змінювати всі закриті елементи і навіть перейменовувати та видаляти їх, не турбуючись, що десь хтось їх використовує у своїх програмах.
На С++:

class Point {

  //можливий доступ лише з методів даного класу
   int x, y; 
   bool visibility; 

public:
  void createPoint(int a, int b) {
    x = a; y = b;
    visibility = true;
  }

  void setVisibility(bool visibility) { 
    this->visibility = visibility;
  }

  int getX() { 
    return x; 
  }

  int getY() { 
    return y; 
  }
};
Поліморфі́зм(з грец. πολύς "багато" + μορφή "форма") — концепція в програмуванні та теорії типів, відповідно до якої використовується спільний інтерфейс для обробки різних спеціалізованих типів.

На противагу поліморфізму, концепція мономорфізму вимагає однозначного зіставлення.
На С++:

class Point {

  private:
   int x, y; 
   char x2,y2;
  public:
    void setXY(int _x, int _y)
    {
      x=_x;
      y=_y;
    }
    void setXY(char _x, char _y)
    {
      x2=_x;
      y2=_y;
    }  
};
